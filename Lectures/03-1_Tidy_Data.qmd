---
title: "Template Title"
subtitle: "Subtitle"
author:
  - Elizabeth King
  - Kevin Middleton
format:
  revealjs:
    theme: [default, custom.scss]
    standalone: true
    self-contained: true
    logo: QMLS_Logo.png
    slide-number: true
    show-slide-number: all
code-annotations: hover
bibliography: QMLS_Bibliography.bib
csl: evolution.csl
---


```{r setup, echo=FALSE, message=FALSE}
library(tidyverse)
library(readxl)
library(cowplot)
theme_set(theme_cowplot())
```

<!--
Datasets:
  composition_data.csv
-->


## Data Manipulation Goals

- Perform all manipulation in R
  - Preserves data integrity
  - This will take a lot of time at first but is worth the effort
  - Remember Google is your friend!
  
  
## Tibbles

Two main differences between tibbles and data.frames
  
  **2. Subsetting:** is done by name with `$`, or by name or position with `[[]]`.


```{r, echo=FALSE, eval=TRUE}
df <- tibble(
  x = runif(5),
  y = rnorm(5)
)
```

```{r, echo=TRUE, eval=TRUE}
df
```


## Subsetting Tibbles

Extract by name
```{r, echo=TRUE, eval=TRUE}
df$x
df[["x"]]
```

Extract by position
```{r, echo=TRUE, eval=TRUE}

df[[1]]
```


## Subsetting Tibbles

When using the pipe `%>%`, you need to use a special placeholder `.` when subsetting:

Here the `.` stands in for the tibble named "df"
```{r, echo=TRUE, eval=TRUE}

df %>% .$x

df %>% .[["x"]]
```

## Placehold from cut

\bigskip



In the tidyverse, you can combine multiple operations with the "pipe", or `%>%`.

-   This makes your code clean and more human-readable if you translate `%>%` to "then".
    
    -   The code above would read, "take `table4a`, then pivot the columns `1999` and `2000` into one longer column named `year`, and its values should be called `cases`."  




## `separate()`  {.smaller}

Pulls apart one column into multiple columns wherever a separator appears.

\scriptsize
```{r, eval=TRUE, echo=FALSE}
print(table3, n = 4, width = Inf)
```

```{r,  echo=TRUE}
table3 %>% 
  separate(rate, into = c("cases", "population"), sep = "/")
```


## `separate()` {.smaller}

If you look carefully, the resulting tibble from the previous set of operations resulted in two new columns that were both *characters* because the original column was a character before the separation. Therefore you should have the function convert to a better type of data using `convert = TRUE`.
<br />
<br />

```{r,  echo=TRUE}
table3 %>% 
  separate(rate, into = c("cases", "population"), sep = "/",
                    convert = TRUE)
```



## `unite()` {.smaller}

Turns two columns into one. The default for `sep` is an underscore (_), so if you want something different you must specify.


```{r, eval=TRUE, echo=FALSE}
table5
```

```{r,  echo=TRUE}
table5 %>% 
  unite(year_4digit, century, year, sep = "")
```


## Missing Values

Manipulating your data brings up the importance of missing values. These can either be...

1. **Explicit** - flagged with an `NA`
2. **Implicit** - not present in the data


## Missing Values

```{r,  echo=TRUE}
frogs <- tibble(
  year     = c(2019, 2019, 2019, 2019, 2018, 2018, 2018),
  individual  = c(1,    2,    3,    4,    2,    3,    4),
  mass     = c(2.88, 3.51, 1.95,   NA, 2.72, 2.17, 3.32))
```


```{r, eval=TRUE, echo=FALSE}
frogs
```



## Missing Values

In our case here, you can make implicit missing values become **explicit** by using `pivot_wider()` to turn the years into columns


```{r, eval=TRUE, echo=TRUE}
frogs %>% 
  pivot_wider(names_from = year, values_from = mass)
```


## Missing Values

If missing values are not important, you can turn these explicit values into **implicit** ones by using `values_drop_na = TRUE`.

\footnotesize
```{r, eval=TRUE, echo=TRUE}
frogs %>%
  pivot_wider(names_from = year, values_from = mass) %>%
  pivot_longer(c('2018','2019'), names_to = "year", values_to = "mass", 
               values_drop_na = TRUE)

```

## Missing Values

You can also make missing values explicit with `complete()`


```{r, eval=TRUE, echo=TRUE}
frogs %>%
  complete(year, individual)
```


## References

::: {#refs}
:::
